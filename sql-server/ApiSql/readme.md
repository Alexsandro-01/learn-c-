# Reposit√≥rios em Entity Framework

J√° estamos avan√ßando com os aprendizados em C#, e chegou a hora de ver como manipular dados de forma organizada. üöÄ

Atualmente, existem muitas formas de se estruturar um programa. Entretanto, algo que todas essas arquiteturas t√™m em comum √© o fato de separarem a camada de acesso aos dados da l√≥gica de neg√≥cio.

> Para criarmos essa separa√ß√£o, geralmente utilizamos o Repository Pattern.

## Um padr√£o para manipular dados de forma organizada

Neste padr√£o de sistema, utilizamos classes ou componentes de modo a encapsular a l√≥gica necess√°ria para persistir os dados, os reposit√≥rios.

Anota a√≠ üñä: Al√©m de evitar o c√≥digo macarr√¥nico, esse padr√£o facilita o gerenciamento do ciclo de vida de objetos e prop√µe um modelo simples para recuper√°-los da base de dados.

Como podemos observar na imagem abaixo, o reposit√≥rio serve como uma camada extra, centralizando as chamadas ao banco de dados em uma √∫nica camada.

![diferen√ßa de uso entre aplica√ß√£o com e sem o padr√£o repository](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-diferen%C3%A7a%20de%20uso%20entre%20aplica%C3%A7%C3%A3o%20com%20e%20sem%20o%20padr%C3%A3o%20repository.jpeg)

A utiliza√ß√£o de reposit√≥rios com o Repository Pattern gera um modelo simples para obter objetos e gerenciar seu ciclo de vida, permitindo a f√°cil substitui√ß√£o de ORMs e fonte de dados. Al√©m disso, facilita os testes automatizados.

> O Mapeamento Relacional de Objetos, ou, no ingl√™s, Object-Relational Mapping, √© uma t√©cnica que permite consultar e manipular dados de um banco de dados usando o paradigma de orienta√ß√£o a objetos.

De olho na dicaüëÄ: Como boa pr√°tica, a camada de acesso ao banco de dados sempre √© a mais baixa de um programa, ent√£o √© comum no dia a dia usarmos um framework para auxiliar na conex√£o e manipula√ß√£o de dados que ocorrem nos reposit√≥rios.

O framework mais famoso para essa tarefa no universo .NET √© o Entity Framework, um ORM open-source para aplica√ß√µes .NET que trabalha com dados em alto n√≠vel de abstra√ß√£o.

O Entity Framework suporta uma infinidade de banco de dados, eliminando a necessidade de se preocupar com as diferentes sintaxes existentes.

E no Repository Pattern as consultas s√£o feitas por meio do reposit√≥rio, usando m√©todos de pesquisa para selecionar os dados que atendam ao crit√©rio especificado pela pessoa usu√°ria. Normalmente, esse crit√©rio √© o valor passado como par√¢metro.

Esse reposit√≥rio √© respons√°vel por realizar a consulta no banco de dados e retornar os dados requisitados, encapsulando a sintaxe de consulta e o mapeamento das tabelas.

Anota a√≠ üñä: Um reposit√≥rio pode implementar uma variedade de opera√ß√µes como o b√°sico CRUD, at√© consultas mais espec√≠ficas. Voc√™ pode criar um reposit√≥rio para cada model ou utilizar um para alterar v√°rias models, dependendo da necessidade.

Agora vamos conhecer mais um pouco de como usar esse padr√£o para definir a arquitetura de um programa? Confira no v√≠deo abaixo.

## Quem n√£o ama testes?

√Ä medida que nosso programa vai ficando mais robusto e lidando com bases de dados externas, temos que criar alternativas para realizar nossos testes.

Essas alternativas podem ser um pouco tortuosas, e levar um tempo consider√°vel para a implementa√ß√£o.

![surpresa](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-surpresa.gif)

Mas calma, antes de se desesperar, saiba que o padr√£o repository tamb√©m nos auxilia nessa tarefa.

![ufa](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-ufa.gif)

Como podemos observar na imagem abaixo, a camada de abstra√ß√£o do¬†`Repository`¬†entre o¬†`Controller`¬†e o¬†`DbContext`¬†permite que, no momento em que realizarmos nossos testes, vamos ter apenas que nos preocupar em realizar mocks do nosso reposit√≥rio, sem se preocupar com a infraestrutura de banco de dados.

![compara√ß√£o entre app sem e com repository_testes](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-compara%C3%A7%C3%A3o%20entre%20app%20sem%20e%20com%20repository_testes.jpeg)

‚ö†Ô∏èAviso: Se n√£o us√°ssemos o¬†`Repository Pattern`, ter√≠amos um problem√£o para testar, pois as consultas ao banco de dados estariam no meio do c√≥digo!

## Criando nossa primeira conex√£o com Entity Framework

Iremos come√ßar criando uma webapi para criar nossos c√≥digos. Entretanto, n√£o iremos criar rotas para manipular todas as tabelas e iremos criar uma rota fixa de exemplo.

Copiar

```shell
1dotnet new webapi -o ApiSql
```

√Ä primeira vista, criar uma conex√£o com o¬†`Entity Framework`¬†pode parecer um bicho de sete cabe√ßas, mas a realidade n√£o √© t√£o assustadora assim.

![monstrinho](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-monstrinho.gif)

Mas, para conseguirmos nossa conex√£o, precisamos de um contexto que nos mostre quais¬†`models`¬†est√£o definidas na base e indique com qual base de dados devemos nos conectar.

O primeiro passo para estabelecermos conex√£o com o banco de dados √© criar uma classe respons√°vel por gerenciar essa conex√£o.

> O Entity Framework disponibiliza uma classe para esse gerenciamento: a¬†`DbContext`, que deve ser herdada da seguinte forma:

Copiar

```csharp
1public class DatabaseContext : DbContext
2{
3
4}
```

O¬†`DbContext`¬†possibilita realizar as opera√ß√µes b√°sicas de leitura, cria√ß√£o, atualiza√ß√£o e exclus√£o em um banco de dados. Al√©m disso, podemos realizar opera√ß√µes com agrega√ß√µes de tabelas.

Para indicarmos qual deve ser a base de dados com que a nossa aplica√ß√£o deve se comunicar, precisaremos sobrescrever a fun√ß√£o¬†`OnConfiguring`, que recebe como par√¢metro uma vari√°vel do tipo¬†`DbContextOptionsBuilder`.

Copiar

```csharp
1public class DatabaseContext : DbContext
2{
3    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
4    {
5        optionsBuilder.UseSqlServer(@"Server=127.0.0.1;Database=master;User=SA;Password=password123!;");
6    }
7}
```

Repare que, por meio da nossa vari√°vel¬†`optionsBuilder`, estamos informando para nossa aplica√ß√£o que a nossa conex√£o ser√° realizada com um banco de dados do tipo¬†**Sql Server**¬†e passando a nossa string de conex√£o.

> De olho na dicaüëÄ: Entity Framework suporta v√°rios tipos de banco de dados, para cada um deles temos uma biblioteca que nos fornece utilit√°rios para a cria√ß√£o da conex√£o. Para adicionar a biblioteca referente ao Sql Server, basta rodar no console¬†`dotnet add package Microsoft.EntityFrameworkCore.SqlServer`.

Nossa string de conex√£o passa as informa√ß√µes necess√°rias para se criar uma conex√£o entre a aplica√ß√£o e o banco de dados.

Agora vamos definir quais tabelas mapear na nossa aplica√ß√£o. Digamos que temos o seguinte modelo de dados:

![modelo de banco de dados](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-modelo%20de%20banco%20de%20dados.jpeg)

Para nossa aplica√ß√£o poder manipular essas tabelas, vamos precisar criar uma classe para cada e definir suas rela√ß√µes. Vamos marcar nossas chaves estrangeiras e prim√°rias utilizando um recurso do C# chamado Data Annotations.

Copiar

```csharp
1public class Book
2{
3    [Key]
4    public int BookId { get; set; }
5    public string Title { get; set; }
6    public string Description { get; set; }
7    public string Genre { get; set; }
8    public int Year { get; set; }
9    public int Pages { get; set; }
10    [ForeignKey("AuthorId")]
11    public int? AuthorId { get; set; }
12     public Author Author { get; set; }
13     [ForeignKey("PublisherId")]
14    public int? PublisherId { get; set; }
15    public Publisher Publisher { get; set; }
16}
```

[Acesse o c√≥digo completo aqui](https://github.com/tryber/csharp-codes/blob/S5-D2-L3-EX2/ApiSql/Models/Book.cs)

Copiar

```csharp
1public class Author
2{
3    [Key]
4    public int AuthorId { get; set; }
5    public string Name { get; set; }
6    public string Email { get; set; }
7    [InverseProperty("Author")]
8    public ICollection<Book> Books { get; set; }
9}
```

[Acesse o c√≥digo completo aqui](https://github.com/tryber/csharp-codes/blob/S5-D2-L3-EX2/ApiSql/Models/Author.cs)

Copiar

```csharp
1public class Publisher
2{
3    [Key]
4    public int PublisherId { get; set; }
5    public string Name { get; set; }
6    [InverseProperty("Publisher")]
7    public ICollection<Book> Books { get; set; }
8}
```

[Acesse o c√≥digo completo aqui](https://github.com/tryber/csharp-codes/blob/S5-D2-L3-EX2/ApiSql/Models/Publisher.cs)

- Para o Entity Framework, cada uma dessas classes √© uma entidade.

> Anota a√≠ üñä: Uma entidade √© um objeto que mapeia uma ou mais tabelas de um banco de dados. Para conseguir manipul√°-las no programa, vamos precisar mape√°-las em nosso¬†`context`.

Copiar

```csharp
1// Renomeado DatabaseContext para BookContext
2public class BookContext : DbContext
3{
4    public DbSet<Book> Books { get; set; }
5
6    public DbSet<Publisher> Publishers { get; set; }
7
8    public DbSet<Author> Authors { get; set; }
9
10    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
11    {
12        optionsBuilder.UseSqlServer(@"Server=127.0.0.1;Database=master;User=SA;Password=password123!;");
13    }
14}
```

Dessa forma, nossa aplica√ß√£o j√° sabe qual base de dados vamos utilizar, suas credenciais e quais tabelas queremos manipular.

> _Anota a√≠‚úèÔ∏è: O nome¬†`BookContext`¬†√© arbitr√°rio e podemos utilizar o que melhor se encaixa com a aplica√ß√£o que estamos criando_

## Reposit√≥rios

Agora que aprendemos como nos conectar com o banco de dados, vamos criar um reposit√≥rio e concentrar todas as opera√ß√µes de banco de dados nele.

Um reposit√≥rio √© basicamente uma classe que cont√©m nela m√©todos que encapsulam as regras de neg√≥cio do banco de dados.

Vamos ent√£o criar um reposit√≥rio para as entidades¬†`Book`,¬†`Publisher`¬†e¬†`Author`.

Primeiro, precisamos que nossa classe tenha o atributo respons√°vel pela comunica√ß√£o com o banco de dados. Neste caso, o DbContext¬†`BookRepository`¬†criado anteriormente. E adicionamos este atributo por meio da inje√ß√£o de depend√™ncias, da seguinte forma.

Copiar

```csharp
1public class BookRepository
2{
3  private readonly BookContext _context;
4
5  public BookRepository(BookContext context)
6  {
7    _context = context;
8  }
9}
```

E por fim, vamos disponibilizar o¬†`BookContext`¬†e o¬†`BookRepository`¬†como servi√ßos para serem injetados por meio de inje√ß√£o de depend√™ncias, fazemos isso com o seguinte trecho de c√≥digo no arquivo¬†`Program.cs`:

Copiar

```csharp
1builder.Services.AddDbContext<BookContext>();
2builder.Services.AddScoped<BookContext>();
3builder.Services.AddScoped<BookRepository>();
```

[Acesse o c√≥digo completo aqui](https://github.com/tryber/csharp-codes/blob/S5-D2-L3-EX2/ApiSql/Program.cs)

Agora o nosso reposit√≥rio j√° tem acesso ao contexto de banco de dados que foi injetado por meio de inje√ß√£o de depend√™ncias.

Com isso, podemos come√ßar a criar os m√©todos que ser√£o respons√°veis pelas altera√ß√µes no banco de dados, utilizando para isso o contexto.

## Lendo registros com Reposit√≥rios

Vamos come√ßar a explorar as possibilidades que temos em trabalhar com reposit√≥rios?

Relembrandoüß†: O nosso¬†`BookRepository`¬†recebe em seu construtor uma inst√¢ncia de¬†`DbContext`.

Copiar

```csharp
1public class BookRepository
2{
3    protected readonly DbContext _context;
4    public BookRepository(DbContext context)
5    {
6        _context = context;
7    }
8}
```

- Nossa tabela¬†`Book`¬†tem rela√ß√£o com as tabelas¬†`Author`¬†e¬†`Publisher`, como podemos ver no diagrama abaixo:

![modelo de banco de dados](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-modelo%20de%20banco%20de%20dados.jpeg)

Queremos realizar uma consulta em nossa base de dados, retornando todos os livros. Para isso, vamos (I) chamar nossa conex√£o com o banco de dados, (II) informar a tabela que queremos consultar, e (III) dizer que o banco deve retornar essas informa√ß√µes em forma de lista:

Copiar

```csharp
1public class BookRepository
2{
3    protected readonly DbContext _context;
4    public BookRepository(DbContext context)
5    {
6        _context = context;
7    }
8
9    // Para realizar a consulta, adicionamos um m√©todo
10    // que realiza essa consulta em BookRepository
11    public List<Book?> GetBookList()
12    {
13        var query = _context.Books.ToList();
14
15        return query;
16    }
17}
```

- Ao chamarmos nosso m√©todo¬†`GetBookList`¬†e rodar o programa, nossa sa√≠da ser√°:

Copiar

```console
1Id: 1 - Title: The Hobbit - Pages: 550 - Year: 2011
2Id: 2 - Title: Brave new World - Pages: 325 - Year: 1932
3Id: 3 - Title: The Divine Comedy - Pages: 811 - Year: 2013
```

Agora, vamos dizer que queremos recuperar o t√≠tulo do livro, o nome do autor e o nome da editora com o id 3:

Copiar

```csharp
1public class BookRepository
2{
3    protected readonly DbContext _context;
4    public BookRepository(DbContext context)
5    {
6        _context = context;
7    }
8
9    public List<Book?> GetBookList()
10    {
11        var query = _context.Books.ToList();
12
13        return query;
14    }
15
16    public Book GetById(int id)
17    {
18        return _context.Books.Where(e => e.BookId == id).Include(e => e.Author).Include(e => e.Publisher).First();
19    }
20}
```

- Ao chamarmos nosso m√©todo¬†`GetById`¬†e rodar o programa, nossa sa√≠da ser√°:

Copiar

```console
1Id: 3 - Title: The Divine Comedy - Author: Dante Alighieri - Publisher: Paradise Publisher
```

Quando utilizamos o m√©todo¬†`.Includes`¬†na pesquisa, conseguimos incluir tamb√©m as entidades¬†`Author`¬†e¬†`Publisher`¬†no resultado da consulta, n√£o sendo necess√°rio realizar uma nova consulta para buscar estas informa√ß√µes do livro.

## Status: em um relacionamento s√©rio

Entre as nossas tabelas¬†`Book`,¬†`Publisher`¬†e¬†`Author`, temos um relacionamento conforme mostra a figura abaixo:

![modelo de banco de dados](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-modelo%20de%20banco%20de%20dados.jpeg)

Em nossa classe¬†`Book`, definimos tamb√©m o relacionamento entre¬†`Publisher`¬†e¬†`Author`¬†adicionando a anota√ß√£o¬†`ForeignKey`¬†nas inst√¢ncias da classe¬†`Author`¬†e¬†`Publisher`.

Copiar

```csharp
1public class Book
2{
3    [Key]
4    public int BookId { get; set; }
5    public string Title { get; set; }
6    public string Description { get; set; }
7    public string Genre { get; set; }
8    public int Year { get; set; }
9    public int Pages { get; set; }
10    public int? AuthorId { get; set; }
11    [ForeignKey("AuthorId")]
12    public Author Author { get; set; }
13    public int? PublisherId { get; set; }
14    [ForeignKey("PublisherId")]
15    public Publisher Publisher { get; set; }
16}
```

Em nosso context, precisamos agora fazer o mapeamento da classe¬†`Book`¬†e definir suas rela√ß√µes com as classes¬†`Author`¬†e¬†`Publisher`¬†na fun√ß√£o¬†`OnModelCreating`¬†utilizando FluentAPI.

Copiar

```csharp
1public class BookContext : DbContext
2{
3    public DbSet<Book> Books { get; set; }
4    public DbSet<Author> Authors { get; set; }
5    public DbSet<Publisher> Publishers { get; set; }
6    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
7    {
8        optionsBuilder.UseSqlServer(@"Server=127.0.0.1;Database=master;User=SA;Password=Password12!;");
9    }
10
11    protected override void OnModelCreating(ModelBuilder modelBuilder)
12    {
13        // Defini√ß√£o da rela√ß√£o com Author
14        modelBuilder.Entity<Book>()
15            .HasOne(b => b.Author)
16            .WithMany(a => a.Books)
17            .HasForeignKey(b => b.AuthorId);
18
19        // Defini√ß√£o da rela√ß√£o com Publisher
20        modelBuilder.Entity<Book>()
21            .HasOne(b => b.Publisher)
22            .WithMany(p => p.Books)
23            .HasForeignKey(b => b.PublisherId);
24    }
25}
```

[Acesse o c√≥digo completo aqui](https://github.com/tryber/csharp-codes/blob/S5-D2-L3-EX2/ApiSql/Repository/BookContext.cs)

- Agora voltamos ao nosso¬†`BookRepository`, que vai ser respons√°vel por todos os registros necess√°rios para criarmos um¬†`Book`.
    
- Vamos passar uma inst√¢ncia de¬†`BookContext`¬†no nosso construtor e criar uma fun√ß√£o chamada¬†`Add`¬†dentro dela.
    

Copiar

```csharp
1public class BookRepository
2{
3    protected readonly DbContext _context;
4    public BookRepository(DbContext context)
5    {
6        _context = context;
7    }
8
9    // ...
10
11    public Book Add(Book book)
12    {
13
14    }
15}
```

Agora vamos implementar nossa fun√ß√£o¬†`Add`:

Copiar

```csharp
1public Book Add(Book book)
2{
3    // Sempre utilizamos o contexto de banco de dados que 
4    // √© um membro da classe BookRepository
5    _context.Add(book);
6    _context.SaveChanges();
7    return book;
8}
```

## Atualizando registros com reposit√≥rios

Por meio de reposit√≥rios conseguimos alterar dados de todos os membros desse relacionamento.

- Como as tabelas¬†`Author`¬†e¬†`Publisher`¬†possuem uma refer√™ncia com a tabela¬†`Book`, √© poss√≠vel alterarmos um dado delas utilizando essa refer√™ncia.

![modelo de banco de dados](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-modelo%20de%20banco%20de%20dados.jpeg)

Vamos criar nosso repository¬†`BookRepository`¬†passando uma inst√¢ncia de¬†`DbContext`¬†no nosso construtor e declarar uma fun√ß√£o chamada¬†`Update`¬†dentro dela.

Copiar

```csharp
1public class BookRepository
2{
3    protected readonly DbContext _context;
4    public BookRepository(DbContext context)
5    {
6        _context = context;
7    }
8
9    // ...
10
11    public Book Update(Book book)
12    {
13
14    }
15}
```

O m√©todo¬†`Update`¬†√© simples, como recebemos o¬†`Book`¬†com os novos registros que queremos atualizar, basta chamar o m√©todo¬†`Update`¬†do contexto da seguinte forma:

Copiar

```csharp
1public class BookRepository
2{
3    protected readonly DbContext _context;
4    public BookRepository(DbContext context)
5    {
6        _context = context;
7    }
8
9    public virtual void Update(Book book)
10    {
11        _context.Update(book);
12        _context.SaveChanges();
13    }
14}
```

Vamos conferir como est√° nosso registro na tabela¬†`Publisher`¬†no banco de dados antes de rodarmos o programa:

![consulta no banco de dados](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-consulta%20no%20banco%20de%20dados.png)

Voltando ao banco de dados, realizaremos novamente a consulta na tabela¬†`Publisher`.

![consulta no banco de dados depois do comando](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-consulta%20no%20banco%20de%20dados%20depois%20do%20comando.png)

Com o aux√≠lio do reposit√≥rio, conseguimos alterar v√°rios dados em diferentes tabelas, em simult√¢neo, poupando tempo e c√≥digo.üéâ

## N√£o deixando pedra sobre pedra

Talvez voc√™ possa estar se perguntando: Se eu quiser apagar todos os registros relacionados a uma certa classe, eu consigo? ü§î Resposta: Sim! Com reposit√≥rios tamb√©m podemos fazer isso!

![bot√£o delete](https://content-assets.betrybe.com/prod/34b23d36-6602-4c6c-9b70-aa3f78fcbc05-bot%C3%A3o%20delete.gif)

Para isso, criaremos um novo m√©todo chamado¬†`DeleteBook`¬†em nosso reposit√≥rio¬†`BookRepository`¬†da seguinte forma:

Copiar

```csharp
1public class BookRepository
2{
3    protected readonly DbContext _context;
4    public BookRepository(DbContext context)
5    {
6        _context = context;
7    }
8    public virtual void DeleteBook(int id)
9    {
10        // realizamos uma busca em nossa base para encontrarmos
11        // o livro e suas associa√ß√µes, pelo id do livro, que 
12        // gostar√≠amos de excluir
13        var book = _context.Books.Include(e => e.Author).Include(e => e.Publisher).Single(p => p.BookId == id);
14        _context.Remove(book); // removemos o livro
15        _context.Remove(book.Author); //removemos o autor relacionado
16        _context.Remove(book.Publisher); // remove a editora associada
17        _context.SaveChanges(); //ao final salvamos nossa exclus√£o, para isso se refletir em nosso banco
18    }
19}
```

Ao chamarmos nossa fun√ß√£o¬†`Delete`, passamos um¬†`id`, sendo a chave prim√°ria de¬†`Books`. Dentro dessa fun√ß√£o, vamos realizar uma pesquisa para encontrarmos nossa entidade m√£e e suas tabelas agregadas. Por fim, removemos nossa inst√¢ncia de¬†`Book`¬†e as inst√¢ncias agregadas de¬†`Author`¬†e¬†`Publisher`.

De olho na dica üëÄ: Esse comportamento de eliminar registros que n√£o s√£o mais necess√°rios pode ser considerado uma boa pr√°tica de programa√ß√£o para n√£o armazenarmos registros que n√£o est√£o sendo usados, mantendo assim a integridade do nosso banco de dados.

[Acesse o c√≥digo completo da repository aqui](https://github.com/tryber/csharp-codes/blob/S5-D2-L3-EX2/ApiSql/Repository/BookRepository.cs)

## Utilizando os reposit√≥rios

Para exemplificar o uso de nossos reposit√≥rios, vamos criar uma controller chamada¬†`BookController`. Essa classe ter√° um construtor que receber√° o nosso¬†`BookRepository`. Isso s√≥ √© poss√≠vel gra√ßas √† inje√ß√£o de depend√™ncias.

Copiar

```csharp
1namespace ApiSql.Controllers;
2using Microsoft.AspNetCore.Mvc;
3using ApiSql.Models;
4using ApiSql.Repository;
5
6[ApiController]
7[Route("[controller]")]
8public class BookController : ControllerBase
9{
10
11    private readonly BookRepository _repository;
12    public BookController(BookRepository repository)
13    {
14        _repository = repository;
15    }
16}
```

Agora iremos criar um m√©todo¬†`POST`¬†fixo adicionando o livro¬†`The Divine Comedy`¬†para exemplificar:

Copiar

```csharp
1[HttpPost]
2public IActionResult AddBook()
3{
4    var book = new Book
5    {
6        Title = "The Divine Comedy",
7        Description = "A journey through the infinite torment of Hell",
8        Year = 2013,
9        Pages = 811,
10        Genre = "Drama",
11        Author = new Author
12        {
13            Name = "Dante Alighieri",
14            Email = "mail@mail.com"
15        },
16        Publisher = new Publisher
17        {
18            Name = "Paradise Publisher"
19        }
20    };
21
22    _repository.Add(book);
23
24    return Ok(new { message = "Book added"});
25}
```

[Acesse o c√≥digo completo aqui](https://github.com/tryber/csharp-codes/blob/S5-D2-L3-EX2/ApiSql/Controllers/BookController.cs)

Note que instanciamos um novo¬†`Book`¬†e enquanto preenchemos os dados, instanciamos as classes¬†`Author`¬†e¬†`Publisher`¬†que ir√° gerar um novo livro completo. Ao chamar a¬†`repository`, podemos ver no banco de dados que um novo¬†`Book`,¬†`Author`¬†e¬†`Publisher`¬†s√£o instanciados.